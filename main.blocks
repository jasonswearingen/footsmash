<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable id="1q[SS{uWZ.2b)c45:jST">mySprite</variable></variables><block type="pxt-on-start" id="mw;L5n@ymF78BO%k_=l=" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="Ih,nQlX$ZPy[/{#3QXgr" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace FootSmash {" line1="" line2="    /** how fast the game runs.  increase to simulate &quot;turbo mode&quot;" line3="     * if your algorithms are done properly, changing this should not impact physics simulation / gameplay logic" line4="     *  */" line5="    let GAME_SPEED = 5.0 //default normal = 5.0" line6="    // y position where the game's &quot;ground&quot; should be" line7="    let GROUND = 120" line8="    let WALL_LEFT = 5;" line9="    let WALL_RIGHT = 155;" line10="    // constant acceleration when jumping" line11="    let GRAVITY = -9.8" line12="" line13="" line14="    /** sprites categoriezed by player+body part.  used for core divekick mechanics  */" line15="    namespace PlayerSpriteKind {" line16="        export const P1_Head = SpriteKind.create()" line17="        export const P1_Body = SpriteKind.create()" line18="        export const P1_Foot = SpriteKind.create()" line19="        export const P2_Head = SpriteKind.create()" line20="        export const P2_Body = SpriteKind.create()" line21="        export const P2_Foot = SpriteKind.create()" line22="    }" line23="" line24="    /** simple finite state machine */" line25="    namespace PlayerStates {" line26="        export interface IState&lt;TOwner&gt; {" line27="            update(elapsedSec: number, owner: TOwner): IState&lt;TOwner&gt;;" line28="        }" line29="        export class Idle implements IState&lt;Player&gt;{" line30="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line31="                if (owner.actionButton.isPressed() === false) {" line32="                    return this;" line33="                }" line34="                return new Jumping(owner);" line35="            }" line36="        }" line37="" line38="        export class Jumping implements IState&lt;Player&gt;{" line39="" line40="            /** we transition from Idle state when the jump button is pressed.  " line41="             * need to wait for player to release jump */" line42="            public isJumpStillPressed: boolean;" line43="            /** how fast up (or down) we are going. */" line44="            public yVelocity: number;" line45="            // public yAccel" line46="" line47="            constructor(owner: Player) {" line48="                this.yVelocity = owner.speed;" line49="                this.isJumpStillPressed = true;" line50="" line51="            }" line52="" line53="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line54="" line55="                //move up/down by &quot;gravity&quot;" line56="                let newHeight = owner.height + (this.yVelocity * elapsedSec);" line57="                this.yVelocity += GRAVITY * elapsedSec;" line58="                owner.standY(newHeight);" line59="" line60="                //if at or below zero, back to standing" line61="                if (newHeight &lt;= 0) {" line62="                    owner.standY(0);" line63="                    return new Idle();" line64="                }" line65="" line66="" line67="                if (this.isJumpStillPressed) {" line68="                    if (owner.actionButton.isPressed() === false) {" line69="                        //jump released for first time" line70="                        this.isJumpStillPressed = false;" line71="                    }" line72="                } else if (owner.actionButton.isPressed() === true) {" line73="                    //pressed the action button again!  now DIVE!         " line74="                    return new Dive();" line75="                }" line76="" line77="                return this;" line78="            }" line79="        }" line80="        export class Dive implements IState&lt;Player&gt;{" line81="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line82="" line83="                throw &quot;to implement&quot;;" line84="                return this;" line85="                //not implemented, just return back to Idle" line86="                //return new Idle();" line87="            }" line88="        }" line89="" line90="    }" line91="    class Player {" line92="" line93="        height: number = 0;" line94="        speed = 38.0;" line95="        public head: Sprite;" line96="        public body: Sprite;" line97="        public foot: Sprite;" line98="        public diveBody: Sprite;" line99="        /** when this changes, sprites will be flipped */" line100="        public isFacingRight: boolean = true;" line101="" line102="        public actionButton: controller.Button;" line103="" line104="        public currentState: PlayerStates.IState&lt;Player&gt;;" line105="" line106="        constructor(public isP1: boolean, public xPos: number) {" line107="" line108="            if (isP1) {" line109="                this.body = sprites.create(assets.image`Body1`, PlayerSpriteKind.P1_Body);" line110="                this.diveBody = sprites.create(assets.image`DiveBody1`, PlayerSpriteKind.P1_Body);" line111="                this.head = sprites.create(assets.image`Head1`, PlayerSpriteKind.P1_Head);" line112="                this.foot = sprites.create(assets.image`Foot1`, PlayerSpriteKind.P1_Foot);" line113="" line114="" line115="                this.actionButton = controller.B;" line116="            } else {" line117="                this.body = sprites.create(assets.image`Body2`, PlayerSpriteKind.P2_Body);" line118="                this.diveBody = sprites.create(assets.image`DiveBody2`, PlayerSpriteKind.P2_Body);" line119="                this.head = sprites.create(assets.image`Head2`, PlayerSpriteKind.P2_Head);" line120="                this.foot = sprites.create(assets.image`Foot2`, PlayerSpriteKind.P2_Foot);" line121="" line122="                this.actionButton = controller.A;" line123="            }" line124="" line125="            //hide" line126="            this.diveBody.setPosition(-100, -100);" line127="" line128="            //set position;" line129="            this.stand(xPos, 0);" line130="" line131="            this.currentState = new PlayerStates.Idle();" line132="" line133="" line134="" line135="        }" line136="" line137="        public update(elapsedSec: number) {" line138="            this.currentState = this.currentState.update(elapsedSec, this);" line139="            this._updateSpriteDirections();" line140="        }" line141="" line142="        private _updateSpriteDirections() {" line143="            //get facing direction of this player" line144="            {" line145="                let newIsFacingRight = false;" line146="                //first get facing of p1" line147="                if (myGame.p1.xPos &lt; myGame.p2.xPos) {" line148="                    newIsFacingRight = true;" line149="                } else {" line150="                    newIsFacingRight = false;" line151="                }" line152="                if (this.isP1 === false) {" line153="                    //if actually p2, just switch facing" line154="                    newIsFacingRight = !newIsFacingRight;" line155="                }" line156="                if (newIsFacingRight != this.isFacingRight) {" line157="                    this.isFacingRight = newIsFacingRight;" line158="                    //flip all sprites" line159="                    this.head.image.flipX();" line160="                    this.body.image.flipX();" line161="                    this.foot.image.flipX();" line162="                    this.diveBody.image.flipX();" line163="                }" line164="            }" line165="        }" line166="" line167="        public stand(xPos: number, height: number): void {" line168="            this.xPos = xPos;" line169="            this.height = height;" line170="" line171="            let y = GROUND - height;" line172="" line173="            this.head.setPosition(xPos, y - 35);" line174="            this.body.setPosition(xPos, y - 20);" line175="            this.foot.setPosition(xPos, y - 5);" line176="        }" line177="        /** set character to standing, only passing in a height */" line178="        public standY(height: number): void {" line179="            this.stand(this.xPos, height);" line180="        }" line181="    }" line182="" line183="    export class MyGame {" line184="        public p1 = new Player(true, WALL_LEFT);" line185="        public p2 = new Player(false, WALL_RIGHT);" line186="        private lastUpdateTimestamp: number;" line187="" line188="        constructor() {" line189="            this.lastUpdateTimestamp = game.runtime();" line190="        }" line191="" line192="" line193="        public pumpUpdate() {" line194="            //calculate time since last call to this function" line195="            let currentTimestamp = game.runtime();" line196="            let elapsedMs = currentTimestamp - this.lastUpdateTimestamp;" line197="            let elapsedSec = (elapsedMs / 1000.0) * GAME_SPEED;" line198="" line199="" line200="            this.update(elapsedSec);" line201="" line202="" line203="            this.lastUpdateTimestamp = currentTimestamp;" line204="        }" line205="" line206="        private update(elapsedSec: number) {" line207="            this.p1.update(elapsedSec);" line208="            this.p2.update(elapsedSec);" line209="        }" line210="    }" line211="" line212="}" numlines="213"></mutation><next><block type="typescript_statement" id="ZVXCCNK9:cPy5%9fQQ8B" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let myGame = new FootSmash.MyGame();" numlines="1" declaredvars="myGame"></mutation></block></next></block></statement></block><block type="forever" id="bvyJM4.wxb2:S6OxjyX+" x="1062" y="0"><statement name="HANDLER"><block type="typescript_statement" id="`.U:TnA%=_%i+9,;G5q/" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="myGame.pumpUpdate();" numlines="1"></mutation></block></statement></block><block type="sprite_change_scale" id="YzHwfXkFxj59(AUMDbnE" disabled="true" x="1330" y="390"><field name="anchor">ScaleAnchor.Middle</field><value name="sprite"><block type="variables_get" id="f~YD70aj~]?{KCc`g8f6" disabled="true"><field name="VAR" id="1q[SS{uWZ.2b)c45:jST">mySprite</field></block></value><value name="value"><shadow type="math_number" id="UyauU|uQj$ACKp3,C:R5" disabled="true"><field name="NUM">1</field></shadow></value></block></xml>