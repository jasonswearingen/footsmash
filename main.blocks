<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable id="|g_(FD;avs#OG0c?Tvh#">mySprite</variable></variables><block type="pxt-on-start" id="yyDr[C=}z8c46y_L}}Rk" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="6Q`I,_L5Lr]NGEa*gizk" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace FootSmash {" line1="" line2="    /** how fast the game runs.  increase to simulate &quot;turbo mode&quot;" line3="     * if your algorithms are done properly, changing this should not impact physics simulation / gameplay logic" line4="     *  */" line5="    let GAME_SPEED = 5.0 //default normal = 5.0" line6="    // y position where the game's &quot;ground&quot; should be" line7="    let GROUND = 120" line8="    // constant acceleration when jumping" line9="    let GRAVITY = -9.8" line10="" line11="" line12="    /** sprites categoriezed by player+body part.  used for core divekick mechanics  */" line13="    namespace PlayerSpriteKind {" line14="        export const P1_Head = SpriteKind.create()" line15="        export const P1_Body = SpriteKind.create()" line16="        export const P1_Foot = SpriteKind.create()" line17="        export const P2_Head = SpriteKind.create()" line18="        export const P2_Body = SpriteKind.create()" line19="        export const P2_Foot = SpriteKind.create()" line20="    }" line21="" line22="    /** simple finite state machine */" line23="    namespace PlayerStates {" line24="        export interface IState&lt;TOwner&gt; {" line25="            update(elapsedSec: number, owner: TOwner): IState&lt;TOwner&gt;;" line26="        }" line27="        export class Idle implements IState&lt;Player&gt;{" line28="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line29="                if (owner.actionButton.isPressed() === false) {" line30="                    return this;" line31="                }" line32="                return new Jumping(owner);" line33="            }" line34="        }" line35="" line36="        export class Jumping implements IState&lt;Player&gt;{" line37="" line38="            /** we transition from Idle state when the jump button is pressed.  " line39="             * need to wait for player to release jump */" line40="            public isJumpStillPressed: boolean;" line41="            /** how fast up (or down) we are going. */" line42="            public yVelocity: number;" line43="            // public yAccel" line44="" line45="            constructor(owner: Player) {" line46="                this.yVelocity = owner.speed;" line47="                this.isJumpStillPressed = true;" line48="" line49="            }" line50="" line51="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line52="" line53="                //move up/down by &quot;gravity&quot;" line54="                let newHeight = owner.height + (this.yVelocity * elapsedSec);" line55="                this.yVelocity += GRAVITY * elapsedSec;" line56="                owner.standY(newHeight);" line57="" line58="                //if at or below zero, back to standing" line59="                if (newHeight &lt;= 0) {" line60="                    owner.standY(0);" line61="                    return new Idle();" line62="                }" line63="" line64="" line65="                if (this.isJumpStillPressed &amp;&amp; owner.actionButton.isPressed() === false) {" line66="                    //jump released for first time" line67="                    this.isJumpStillPressed = false;" line68="                } else if (owner.actionButton.isPressed() === true) {" line69="                    //pressed the action button again!  now DIVE!         " line70="                    //return new Dive();" line71="                }" line72="" line73="                return this;" line74="            }" line75="        }" line76="        export class Dive implements IState&lt;Player&gt;{" line77="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line78="" line79="                //return this;" line80="                //not implemented, just return back to Idle" line81="                return new Idle();" line82="            }" line83="        }" line84="" line85="    }" line86="    class Player {" line87="" line88="        height: number = 0;" line89="        speed = 38.0;" line90="        public head: Sprite;" line91="        public body: Sprite;" line92="        public foot: Sprite;" line93="        public diveBody: Sprite;" line94="" line95="        public actionButton: controller.Button;" line96="" line97="        public currentState: PlayerStates.IState&lt;Player&gt;;" line98="" line99="        constructor(public isP1: boolean, public xPos: number) {" line100="" line101="            if (isP1) {" line102="                this.head = sprites.create(assets.image`Head1`, PlayerSpriteKind.P1_Head);" line103="                this.body = sprites.create(assets.image`Body1`, PlayerSpriteKind.P1_Body);" line104="                this.diveBody = sprites.create(assets.image`DiveBody1`, PlayerSpriteKind.P1_Body);" line105="                this.foot = sprites.create(assets.image`Foot1`, PlayerSpriteKind.P1_Foot);" line106="" line107="                this.actionButton = controller.B;" line108="            } else {" line109="                this.head = sprites.create(assets.image`Head2`, PlayerSpriteKind.P2_Head);" line110="                this.body = sprites.create(assets.image`Body2`, PlayerSpriteKind.P2_Body);" line111="                this.diveBody = sprites.create(assets.image`DiveBody2`, PlayerSpriteKind.P2_Body);" line112="                this.foot = sprites.create(assets.image`Foot2`, PlayerSpriteKind.P2_Foot);" line113="                this.actionButton = controller.A;" line114="            }" line115="            //set position;" line116="            this.stand(xPos, 0);" line117="" line118="            this.currentState = new PlayerStates.Idle();" line119="" line120="            " line121="        }" line122="" line123="        public update(elapsedSec: number) {" line124="            this.currentState = this.currentState.update(elapsedSec, this);" line125="        }" line126="" line127="        public stand(xPos: number, height: number): void {" line128="            this.xPos = xPos;" line129="            this.height = height;" line130="" line131="            let y = GROUND - height;" line132="            this.head.setPosition(xPos, y - 40);" line133="            this.body.setPosition(xPos, y - 20);" line134="            this.foot.setPosition(xPos, y - 5);" line135="        }" line136="        /** set character to standing, only passing in a height */" line137="        public standY(height: number): void {" line138="            this.stand(this.xPos, height);" line139="        }" line140="    }" line141="" line142="    export class MyGame {" line143="        public p1 = new Player(true, 30);" line144="        public p2 = new Player(false, 130);" line145="        private lastUpdateTimestamp: number;" line146="" line147="        constructor() {" line148="            this.lastUpdateTimestamp = game.runtime();" line149="        }" line150="" line151="" line152="        public pumpUpdate() {" line153="            //calculate time since last call to this function" line154="            let currentTimestamp = game.runtime();" line155="            let elapsedMs = currentTimestamp - this.lastUpdateTimestamp;" line156="            let elapsedSec = (elapsedMs / 1000.0) * GAME_SPEED;" line157="" line158="" line159="            this.update(elapsedSec);" line160="" line161="" line162="            this.lastUpdateTimestamp = currentTimestamp;" line163="        }" line164="" line165="        private update(elapsedSec: number) {" line166="            this.p1.update(elapsedSec);" line167="            this.p2.update(elapsedSec);" line168="        }" line169="    }" line170="" line171="}" numlines="172"></mutation><next><block type="typescript_statement" id="qNe#0b)+tvc7kH-z7!K2" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let myGame = new FootSmash.MyGame();" numlines="1" declaredvars="myGame"></mutation></block></next></block></statement></block><block type="forever" id="4.|gUdX$,FtE$~a.9OL:" x="1082" y="20"><statement name="HANDLER"><block type="typescript_statement" id="PSys8Qn7R82jyTAs6(g," editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="myGame.pumpUpdate();" numlines="1"></mutation></block></statement></block><block type="sprite_change_scale" id="vJsR[jePgSS1RrCTl]:5" disabled="true" x="1350" y="410"><field name="anchor">ScaleAnchor.Middle</field><value name="sprite"><block type="variables_get" id="(f^z_KKW~4ZEa_]pg[au" disabled="true"><field name="VAR" id="|g_(FD;avs#OG0c?Tvh#">mySprite</field></block></value><value name="value"><shadow type="math_number" id="~3EX8x9Cx1yS?:0T7VOJ" disabled="true"><field name="NUM">1</field></shadow></value></block></xml>