<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable id="of8fJ$o%!9u38;q(PKjW">mySprite</variable></variables><block type="pxt-on-start" id="NQD7j`dzD2;!pV~K3)Es" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="URGB[HqvnBa}BsA7l]*Q" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace FootSmash {" line1="    //a namespace is like a box, containing other things (code, variables, classes, other namespaces)" line2="    //everything inside a namespace (box) can see everything else inside. " line3="    //but nothing outside can see any of the contents unless the [export] keyword is used.   " line4="    //[export] is basically the same thing as [public] but for namespaces." line5="" line6="" line7="    /** how fast the game runs.  increase to simulate &quot;turbo mode&quot;" line8="     * if your algorithms are done properly, changing this should not impact physics simulation / gameplay logic" line9="     *  */" line10="    let GAME_SPEED = 10.0 //default normal = 5.0" line11="    /** y position where the game's &quot;ground&quot; should be */" line12="    let GROUND = 120" line13="    /** screen x position of the left game border */" line14="    let WALL_LEFT = 5;" line15="    /** screen x position of the game border  */" line16="    let WALL_RIGHT = 155;" line17="    /** constant acceleration when jumping */" line18="    let GRAVITY = -9.8" line19="" line20="    /** helper to throw an error (for debugging purposes) " line21="     * and still see the proper line number in the stack trace at the bottom of the IDE." line22="     * This is needed because if you just [throw &quot;your err msg&quot;;] it won't show the line number so debugging is annoying.  */" line23="    function THROW_ERROR(message: string) {" line24="        throw message;" line25="    }" line26="" line27="    /** sprites categoriezed by player+body part.  used for core divekick mechanics" line28="     * when foot hits a sprite of kind &quot;Head&quot;, it's a HEADSHOT" line29="     * when foot hits body it's a KO" line30="     * when foot hits foot, and opponent was DIVING state, it's a DOUBLE KO, otherwise just normal KO." line31="      */" line32="    namespace PlayerSpriteKind {" line33="        export const P1_Head = SpriteKind.create()" line34="        export const P1_Body = SpriteKind.create()" line35="        export const P1_Foot = SpriteKind.create()" line36="        export const P2_Head = SpriteKind.create()" line37="        export const P2_Body = SpriteKind.create()" line38="        export const P2_Foot = SpriteKind.create()" line39="    }" line40="" line41="    /** simple &quot;finite state machine&quot; (FSM) used for splitting up the player's game mechanics up into their own modular parts" line42="     * more on FSM: https://www.youtube.com/watch?v=-ZP2Xm-mY4E   and http://gameprogrammingpatterns.com/state.html" line43="      */" line44="    namespace PlayerFSM {" line45="" line46="        /** A State holds all the variables and decisions (logic and state) for the owner when they are in that state.         * " line47="         * This IState is the minimum functionality we need to have a full FSM." line48="         *          " line49="         * See the IdleState and JumpingState for examples " line50="         * " line51="         * an interface is an &quot;example&quot;, saying what functions a class needs to have when it &quot;implements&quot; the interface.  " line52="         * * The &lt;TOwner&gt; is a &quot;generic&quot;, letting the class that implements pick the class that TOwner is.   In our game TOwner is always &quot;Player&quot;" line53="         * */" line54="        export interface IState&lt;TOwner&gt; {" line55="            /** update the state, pasing in it's owner if outside data is required.  " line56="             * should return itself or whatever state that should be transitioned into */" line57="            update(elapsedSec: number, owner: TOwner): IState&lt;TOwner&gt;;" line58="        }" line59="" line60="" line61="        /** Active when player is standing on the ground." line62="         * This is the &quot;Brains&quot; of the player when they are Idle." line63="         * In this Idle, we make sure we are on the ground, and check when it's time to JUMP." line64="         */" line65="        export class IdleState implements IState&lt;Player&gt;{" line66="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line67="" line68="                //if player below ground, teleport to ground" line69="                if (owner.height &lt; 0) {" line70="                    owner.standY(0);" line71="                }" line72="                //if player above ground, start falling to ground" line73="                if (owner.height &gt; 0) {" line74="                    return new JumpingState(owner, 0);" line75="                }" line76="" line77="                //if player presses action, JUMP!" line78="                if (owner.actionButton.isPressed() === true) {" line79="                    return new JumpingState(owner, owner.speed);" line80="                }" line81="" line82="                //nothings happening, just return ourself so next game update this Idle state runs again" line83="                return this;" line84="            }" line85="        }" line86="" line87="        /** Handles when the player is in Jumping (and falling) Mode." line88="         * inside we calculate physics and check when we DIVE or fall back to the ground and switch to IDLE." line89="           */" line90="        export class JumpingState implements IState&lt;Player&gt;{" line91="" line92="            /** when we transition from IDLE to JUMP state, the action button is pressed." line93="             * Because it's pressed, we need to track it, so we know when it was unpressed and pressed again." line94="             * This is because we want the player to DIVE only once they press action a second time. */" line95="            public isJumpStillPressed: boolean;" line96="" line97="            /** a constructor is a function that gets executed on the newly created class instance when it" line98="             * is created via the &quot;new&quot; keyword.  eg: [new JumpingState(p1,0);]" line99="             * this lets us do some initialization work, and store values sent by the code that created this instance." line100="             */" line101="            constructor(owner: Player," line102="                /** how fast up (or down) we are going when we first transition to JUMP.  set to 0 and the character will fall to the ground. */" line103="                public yVelocity: number) {" line104="" line105="                this.isJumpStillPressed = true;" line106="" line107="            }" line108="" line109="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line110="" line111="                //move up/down by &quot;gravity&quot;" line112="                let newHeight = owner.height + (this.yVelocity * elapsedSec);" line113="                this.yVelocity += GRAVITY * elapsedSec;" line114="                owner.standY(newHeight);" line115="" line116="                //if at or below zero, back to standing" line117="                if (newHeight &lt;= 0) {" line118="                    owner.standY(0);" line119="                    return new IdleState();" line120="                }" line121="" line122="" line123="                if (this.isJumpStillPressed) {" line124="                    if (owner.actionButton.isPressed() === false) {" line125="                        //jump released for first time" line126="                        this.isJumpStillPressed = false;" line127="                    }" line128="                } else if (owner.actionButton.isPressed() === true) {" line129="                    //pressed the action button again!  now DIVE!         " line130="                    return new DiveState();" line131="                }" line132="" line133="                return this;" line134="            }" line135="        }" line136="        /** Was &quot;Jumping&quot; to get here.  no time to dive attack! */" line137="        export class DiveState implements IState&lt;Player&gt;{" line138="            public update(elapsedSec: number, owner: Player): IState&lt;Player&gt; {" line139="                //if we just start diving, need to pick a direction to dive." line140="                //if we are at either wall, dive towards center of screen." line141="                //otherwise, dive toward enemy Player" line142="" line143="                //do our dive physics calculation" line144="" line145="                //if our foot sprite collides with enemy do damage function" line146="" line147="                //if our height less than 0, set to 0 and idle." line148="" line149="                //if we hit the wall, transition to jumping (secret ability!) (also easier to code)" line150="" line151="                THROW_ERROR(&quot;need to implement Dive state&quot;);" line152="                return this;" line153="" line154="" line155="" line156="" line157="            }" line158="        }" line159="" line160="    }" line161="    class Player {" line162="" line163="        private _height = 0;" line164="        /** " line165="         * get/set properties in typescript: https://www.typescriptlang.org/docs/handbook/2/classes.html#getters--setters" line166="         */" line167="        public get height() { return this._height; }" line168="" line169="        //private set height(value:number){this._height = value; }" line170="        speed = 38.0;" line171="        public head: Sprite;" line172="        public body: Sprite;" line173="        public foot: Sprite;" line174="        public diveBody: Sprite;" line175="        /** when this changes, sprites will be flipped */" line176="        public isFacingRight: boolean = true;" line177="" line178="        public actionButton: controller.Button;" line179="" line180="        public currentState: PlayerFSM.IState&lt;Player&gt;;" line181="" line182="        constructor(public isP1: boolean, public xPos: number) {" line183="" line184="            if (isP1) {" line185="                this.body = sprites.create(assets.image`Body1`, PlayerSpriteKind.P1_Body);" line186="                this.diveBody = sprites.create(assets.image`DiveBody1`, PlayerSpriteKind.P1_Body);" line187="                this.head = sprites.create(assets.image`Head1`, PlayerSpriteKind.P1_Head);" line188="                this.foot = sprites.create(assets.image`Foot1`, PlayerSpriteKind.P1_Foot);" line189="" line190="" line191="                this.actionButton = controller.B;" line192="            } else {" line193="                this.body = sprites.create(assets.image`Body2`, PlayerSpriteKind.P2_Body);" line194="                this.diveBody = sprites.create(assets.image`DiveBody2`, PlayerSpriteKind.P2_Body);" line195="                this.head = sprites.create(assets.image`Head2`, PlayerSpriteKind.P2_Head);" line196="                this.foot = sprites.create(assets.image`Foot2`, PlayerSpriteKind.P2_Foot);" line197="" line198="                this.actionButton = controller.A;" line199="            }" line200="" line201="            //hide" line202="            this.diveBody.setPosition(-100, -100);" line203="" line204="            //set position;" line205="            this.stand(xPos, 0);" line206="" line207="            this.currentState = new PlayerFSM.IdleState();" line208="" line209="" line210="" line211="        }" line212="" line213="        public update(elapsedSec: number) {" line214="            this.currentState = this.currentState.update(elapsedSec, this);" line215="            this._updateSpriteDirections();" line216="        }" line217="" line218="        private _updateSpriteDirections() {" line219="            //get facing direction of this player" line220="            {" line221="                let newIsFacingRight = false;" line222="                //first get facing of p1" line223="                if (myGame.p1.xPos &lt; myGame.p2.xPos) {" line224="                    newIsFacingRight = true;" line225="                } else {" line226="                    newIsFacingRight = false;" line227="                }" line228="                if (this.isP1 === false) {" line229="                    //if actually p2, just switch facing" line230="                    newIsFacingRight = !newIsFacingRight;" line231="                }" line232="                if (newIsFacingRight != this.isFacingRight) {" line233="                    this.isFacingRight = newIsFacingRight;" line234="                    //flip all sprites" line235="                    this.head.image.flipX();" line236="                    this.body.image.flipX();" line237="                    this.foot.image.flipX();" line238="                    this.diveBody.image.flipX();" line239="                }" line240="            }" line241="        }" line242="" line243="        public stand(xPos: number, height: number): void {" line244="            this.xPos = xPos;" line245="            this._height = height;" line246="" line247="            let y = GROUND - height;" line248="" line249="            this.head.setPosition(xPos, y - 35);" line250="            this.body.setPosition(xPos, y - 20);" line251="            this.foot.setPosition(xPos, y - 5);" line252="        }" line253="        /** set character to standing, only passing in a height */" line254="        public standY(height: number): void {" line255="            this.stand(this.xPos, height);" line256="        }" line257="    }" line258="" line259="    export class MyGame {" line260="        public p1 = new Player(true, WALL_LEFT);" line261="        public p2 = new Player(false, WALL_RIGHT);" line262="        private lastUpdateTimestamp: number;" line263="" line264="        constructor() {" line265="            this.lastUpdateTimestamp = game.runtime();" line266="        }" line267="" line268="" line269="        public pumpUpdate() {" line270="            //calculate time since last call to this function" line271="            let currentTimestamp = game.runtime();" line272="            let elapsedMs = currentTimestamp - this.lastUpdateTimestamp;" line273="            let elapsedSec = (elapsedMs / 1000.0) * GAME_SPEED;" line274="" line275="" line276="            this.update(elapsedSec);" line277="" line278="" line279="            this.lastUpdateTimestamp = currentTimestamp;" line280="        }" line281="" line282="        private update(elapsedSec: number) {" line283="            this.p1.update(elapsedSec);" line284="            this.p2.update(elapsedSec);" line285="        }" line286="    }" line287="" line288="}" numlines="289"></mutation><next><block type="typescript_statement" id="=xGx+ZDXOXLERjF8BT0E" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let myGame = new FootSmash.MyGame();" numlines="1" declaredvars="myGame"></mutation></block></next></block></statement></block><block type="forever" id="56+i:D41J^]J!6v(olZf" x="1062" y="0"><comment pinned="false" h="80" w="160">hooks into the makecode arcade engine to get an update loop</comment><statement name="HANDLER"><block type="typescript_statement" id="]aEwCrw_zn/aR^:vPdx?" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="myGame.pumpUpdate();" numlines="1"></mutation></block></statement></block><block type="sprite_change_scale" id="`w;!q`/mws^0iwpd)e9l" disabled="true" x="1315" y="0"><field name="anchor">ScaleAnchor.Middle</field><value name="sprite"><block type="variables_get" id="wU+a4+OljAYCWCO2Eb:G" disabled="true"><field name="VAR" id="of8fJ$o%!9u38;q(PKjW">mySprite</field></block></value><value name="value"><shadow type="math_number" id="BmH*7w2!CUM.R;B?JKDK" disabled="true"><field name="NUM">1</field></shadow></value></block></xml>